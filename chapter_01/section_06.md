# 运算符

---

## 1. 算数运算

### 1) 普通算数

java 的数值类型支持基本的算术运算：加、减、乘、除、模（余数）

例如：

| 表达式 | 结果 | 说明 |
| :--- | :--- | :--- |
| 3 + 4; | 7 | 加法 |
| 3 - 4; | -1 | 减法 |
| 3 \* 4; | 12 | 乘法 |
| 12 / 4; | 3 | 整数除法 |
| 3 / 4; | 0 | 整数除法，整数除法会忽略所有小数部分 |
| 3 / 0; | ArithmeticException | 整数除法不能除以0，会出现异常 |
| 3.0 / 4.0 | 0.75 | 小数除法 |
| 3.0 / 0.0 | Infinity | 小数除法可以除以0.0 结果是正无穷大 |
| 10 % 3 | 1 | 求模\(余数\) |
| -10 % 3 | -1 | 求模\(余数\) |
| 10.0 % 3.5 | 3.0 | 求模\(余数\) |

### 2) 自增，自减运算

| 表达式 | 结果 | 说明 |
| :--- | :--- | :--- |
| int a = 5; a++; | a变为6 | 自增 |
| int a = 5; a--; | a变为4 | 自减 |
| int a = 5; System.out.println\(a++\); | 打印5, a变为6 | 后自增先执行其它运算，再自增变量 |
| int a = 5; System.out.println\(++a\); | a变为6, 打印6 | 前自增先自增变量，再执行其它运算 |

很多题目中会考核对自增、自减运算符的理解，例如：

```
int a = 5;
int b = a++ + ++a + a++;
```

问最后a和b变量分别是多少？

分析过程如下：

基本原则，从左向右，按照运算符优先级依次解析，赋值=运算最后执行

第二原则，a变量的存储和加法运算分别使用了不同的内存空间，自增运算直接修改a变量的存储空间，而加法运算需要使用到操作栈的空间，初始如图:

![](/chapter_01/3_1.png)

* 首先处理 a++ 它是先准备好一个被加数\(5\)，再自增a为6

![](/chapter_01/3_2.png)

* 其次处理 ++a 它是先自增a为7，再将结果作为加数\(7\)

![](/chapter_01/3_3.png)

* 执行第一个加法运算，5+7=12，并将此结果作为第二次加法的被加数\(12\)

![](/chapter_01/3_4.png)

* 接下来处理最后的 a++ 它是准备好一个加数\(7\)，再自增a为8

![](/chapter_01/3_5.png)

* 执行第二个加法运算，12+7=19，并将此结果赋值给b

![](/chapter_01/3_6.png)

### 3) 移位运算

* 算术右移（考虑符号位，正数移动还是正数，负数移动还是负数）

例如： 3 >> 1 是将3按二进制右移1位，下面举例说明：

| 表达式 | 十进制 | 二进制 | 二进制结果 | 十进制结果 |
| --- | --- | --- | --- | --- |
| 3 >> 1 | 3 | 0000 0011 | 0000 0001 | 1 |
| 8 >> 1 | 8 | 0000 1000 | 0000 0100 | 4 |
| 8 >> 2 | 8 | 0000 1000 | 0000 0010 | 2 |
| 8 >> 3 | 8 | 0000 1000 | 0000 0001 | 1 |

负数移动时，逐位右移，符号位始终置为1：

| 表达式 | 十进制 | 二进制 | 二进制结果 | 十进制结果 |
| --- | --- | --- | --- | --- |
| -128 >> 1 | -128 | 1000 0000 | 1100 0000 | -64 |
| -128 >> 2 | -128 | 1000 0000 | 1110 0000 | -32 |
| -128 >> 3 | -128 | 1000 0000 | 1111 0000 | -16 |

可以得到一个规律，算术右移相当于整数除法，移动1位相当于除2，移动2位相当于除4 ……

* 算数左移，相当于整数乘法

例如：

| 表达式 | 十进制 | 二进制 | 二进制结果 | 十进制结果 |
| --- | --- | --- | --- | --- |
| 3 << 1 | 3 | 0000 0011 | 0000 0110 | 6 |
| 3 << 2 | 3 | 0000 0011 | 0000 1100 | 12 |

* 逻辑右移，与算术右移的区别是，逐位右移，但最高位总是置0：

| 表达式 | 二进制 | 二进制结果 | 十进制结果 |
| --- |  --- | --- | --- |
| -2147483648 >>> 1 | 1000 0000 0000 0000 0000 0000 0000 0000 | 0100 0000 0000 0000 0000 0000 0000 0000 | 1073741824 |

> 注意：因为运算前发生了类型提升，将数字当作了int，因此共有32位。之前的左移和算数右移也类似，做了简化处理。


### 4) 位运算

### 5) 增强赋值运算

## 2. 比较运算

比较运算分为 >=(大于等于)、 >(大于)、 <=(小于等于)、 <(小于)、==(等于)、!=(不等于)

它们可以用来比较基本类型中的数值类型。其中==和!=还可以用来比较引用类型，进行引用类型的比较时，是判断这两个引用是否指向同一个对象。

## 3. 逻辑运算

逻辑运算分为&&(逻辑与)、||(逻辑或)、^(逻辑异或)、!(逻辑非)

| a | b | a && b | a \|\| b | a ^ b |
| :--- | :--- | :--- | :--- | :--- |
| true | true | true | true | false |
| true | false | false | true | true|
| false | true | false | true | true|
| false | false | false | false | false |

| a | !a |
| :--- | :--- |
| true | false |
| false | true |

逻辑运算(&& ||)属于短路运算，意思是只在必须时才执行，例如：
```
4 > 3 || 4 / 0 == 3
```
逻辑或的规则是两个表达式只要有一个结果是true，整个结果就是true

第一个表达式 4 > 3 返回已经是true了，所以第二个表达式不用计算也知道结果为true. 

与之相反，& | ^ 这几个位运算符也可以作为逻辑运算，但它们属于非短路运算，运算符两边的表达式都必须求解。

上个例子如果改为：
```
4 > 3 | 4 / 0 == 3
```
则会报错，因为第二个表达式被执行，它会引发除0异常。

---



