# 类型提升

---

## 1. 不会发生类型提升的地方

首先看看字面量的一些问题：

```
byte a = 50;
short b = 500;
int c = 50000;
```
都是合法的，而且他们没有加特殊的L、F、D 后缀，java 是怎么区分50, 500, 50000 这几个字面量是什么类型呢？其实就是根据他们的取值范围：

50 的范围在byte的取值范围内，因此被视为 byte

500 的范围超过了byte，但在short的取值范围内，因此被视为 short

而50000 的范围超过了short，因此被视为int

下面是一条比较重要的规则：

如果运算的两端都是字面量，不会发生类型提升，这时候java会在编译阶段做数值运算的优化，运算前当作int，运算后根据数值的范围大小当作byte, short或int，例如：

```
10 + 20  
```
其实会被当作 byte 的 30，计算是发生在`编译阶段`，而不是`运行阶段`

## 2. 类型提升发生的时机

前提条件：

* 运算中含有变量时
* 运算中有类型不匹配时
* 运算的类型是`算术运算`或`赋值运算`时

> 注意 `增强赋值运算`和`自增自减`不会发生类型提升

算数运算符包括：

| 符号 | 说明 |
| :--- | :--- |
| + | 加法 |
| - | 减法 |
| * | 乘法 |
| / | 除法 |
| % | 模(取余) |
| & | 按位与 |
| \| | 按位或 |
| ^ | 按位异或 |
| ~ | 按位取反 |
| >> | 算术右移(带符号) |
| >>> | 逻辑右移(无符号) |
| << | 左移 |



## 3. 提升规则

如果运算中的变量都小于等于int则提升为int，有一个变量大于int，则提升为那个更大的类型，小的类型可以赋值给大的类型，但反之不行。

`由小到大`的规律有两条线：

byte  <  short  <  int < long < float < double

char < int < long < float < double

例如：

```
byte a = 10;
byte b = 20;
```

则 a+b 提升为int

再如：

```
int a = 10;
long b = 20L;

```
则 a+b 提升为long


赋值运算同样遵从此规则，例如：

```
int c = 50;
```
这行代码已经发生了类型提升，将byte的50由byte提升为了int

## 4. 常见问题

例：

```
short a = 10;
a = a + 20;
```
第一行代码没有错误，byte 10提升为short 10

第二行代码有问题： a 是变量，因此 a+20 发生了类型提升，且提升为int，int的结果不能直接赋值给short

但注意，如下代码是正确的：
```
short a = 10;
a += 20;
```
因为 += 增强赋值运算符不会发生类型提升

下面的代码也是正确的：
```
short a = 10 + 20;
```
因为 + 运算的两端不包含变量，运算发生在编译期，虽然发生了类型提升 byte 30 提升为short 30，但byte结果可以赋值给short变量

---
