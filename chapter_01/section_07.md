# 类型提升

---

## 1. 字面量的规则

```java
byte a = 50;
short b = 500;
int c = 50000;
```

都是合法的，而且他们没有加特殊的L、F、D 后缀，java 是怎么区分50, 500, 50000 这几个字面量是什么类型呢？其实就是根据他们的取值范围：

50 的范围在byte的取值范围内，因此被视为 byte

500 的范围超过了byte，但在short的取值范围内，因此被视为 short

而50000 的范围超过了short，因此被视为int

如果字面量发生了运算，这时候java会在编译阶段做数值运算的优化，计算是发生在`编译阶段`，而不是`运行阶段`，例如：

```java
byte a = 10 + 20;
```

其实会被当作 byte 的 30 赋值给a变量

## 1. 提升规则

当执行数值相关的运算时，如果参与运算的变量类型不一致，会发生类型提升。
提升规则如下：

* 运算中的变量都小于等于int则提升为int
* 有一个变量大于int，则提升为那个更大的类型
* 小的类型可以直接赋值给大的类型，但反之不行。

`由小到大`的规律有两条线：

byte  &lt;  short  &lt;  int &lt; long &lt; float &lt; double

char &lt; int &lt; long &lt; float &lt; double

例1：

```java
byte a = 10;
byte b = 20;
```

则 a+b 提升为int

例2：

```java
int a = 10;
long b = 20L;
```

则 a+b 提升为long


> 注意 `增强赋值运算`和`自增自减`不会发生类型提升

## 2. 常见问题

例：

```
short a = 10;
a = a + 20;
```

第一行代码没有错误

第二行代码有问题： a 是short变量，因此 a+20 发生了类型提升，且提升为int，int的结果不能直接赋值给short

但注意，如下代码是正确的：

```
short a = 10;
a += 20;
```

因为 += 增强赋值运算符不会发生类型提升

下面的代码也是正确的：

```
short a = 10 + 20;
```

因为 + 运算的两端不包含变量，运算发生在编译期，虽然发生了类型提升 byte 30 提升为short 30，但byte结果可以赋值给short变量，语法是正确的。

---



